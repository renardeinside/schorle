---
alwaysApply: true
---

# Schorle Framework Development Guide

## Tooling

- **ALWAYS** use `uv` for Python package management
- **ALWAYS** use `bun` for node package management
- **ALWAYS** to run `python` use `uv` in a form of `uv run python ...`

Project uses:

- FastAPI for most of the backend operations
- Typer for CLI
- pydantic for state 

## Overview

**Schorle** is a hybrid Python/TypeScript framework that bridges the gap between Python backend development and modern frontend user interfaces. It enables developers to build full-stack applications using Python for business logic while leveraging React/TypeScript for UI components, all within a unified development experience.

## Schorle – Cursor Instructions (Updated Bun SSR Architecture)

> **TL;DR**  
> Schorle now uses **Bun stdin/stdout for building and rendering pages** instead of Next.js. The build step generates **client and server bundles** from template entry files. During rendering, Python passes props (base64), headers, and cookies to the **slx-ipc CLI** and waits for the rendered output. CSS is injected on-the-fly from Python.

---

## 0) Ground Rules for Cursor

- **Bun is the primary runtime** for building and rendering React components via stdin/stdout.
- **No Next.js** - we use custom Bun-based SSR with template-driven bundling.
- **Build generates 2 bundles**: client-side and server-side from template entry files.
- **Rendering uses slx-ipc CLI** with base64-encoded props, headers, and cookies.
- **CSS injection** happens dynamically from Python during render time.
- **File watching** triggers rebuilds in development mode.

## 1) Process Topology

- **Python (FastAPI)**: public HTTP server, owns lifecycle, handles routing, builds bundles, renders pages via slx-ipc.
- **Bun Build Process**: generates client/server bundles from template entry files.
- **slx-ipc CLI**: Bun-based rendering process that receives props via stdin and outputs HTML via stdout.

```bash
Client ──HTTP──▶ Python (FastAPI)
│
├── Build Time:
│   └── Bun Build ──▶ Client Bundle + Server Bundle (from templates)
│
└── Render Time:
    └── slx-ipc CLI (Bun) ──stdin/stdout──▶ SSR HTML
        ↑
        └── Props (base64) + Headers + Cookies
```

## 2) Build System

### 2.1 Build Process

- **Template Entry Files**: Located in `src/schorle/templates/`
  - `client-entry.tsx.jinja` - Client-side hydration entry point
  - `server-entry.tsx.jinja` - Server-side rendering entry point
- **Build Output**: 
  - Client bundle: Browser-ready JavaScript for hydration
  - Server bundle: Node/Bun-compatible bundle for SSR
- **Triggered by**: File changes in development, explicit build commands in production

### 2.2 Bundle Generation

```bash
# Development
bun build --target=browser src/templates/client-entry.tsx --outdir=dist/client
bun build --target=bun src/templates/server-entry.tsx --outdir=dist/server

# Production (with optimizations)
bun build --target=browser --minify src/templates/client-entry.tsx --outdir=dist/client
bun build --target=bun --minify src/templates/server-entry.tsx --outdir=dist/server
```

## 3) Rendering System

### 3.1 slx-ipc CLI Interface

The `slx-ipc` CLI accepts input via stdin and outputs rendered HTML via stdout:

```bash
echo '{"props": "base64EncodedProps", "headers": {...}, "cookies": {...}}' | slx-ipc render
```

### 3.2 Props Flow

1. **Python serializes props** to base64 (MessagePack or JSON)
2. **Combines with headers/cookies** into JSON payload
3. **Pipes to slx-ipc** via stdin
4. **slx-ipc renders** using server bundle
5. **Returns HTML** via stdout to Python

### 3.3 CSS Injection

- **Python maintains CSS registry** of component styles
- **Injects CSS** directly into HTML during render process
- **No build-time CSS bundling** - dynamic injection for flexibility

## 4) Usage Patterns

### 4.1 Server-side Component Example

```tsx
// src/components/StatsPage.tsx
interface Props {
  totalUsers: number;
}

export default function StatsPage({ totalUsers }: Props) {
  return <div>Users: {totalUsers}</div>;
}
```

### 4.2 Python Render Call

```python
# In Python FastAPI route
from schorle import Schorle
from fastapi import FastAPI 
from pydantic import BaseModel

class Stats(BaseModel):
  total_users: int

ui = Schorle()
app = FastAPI()

ui.mount(app)

@app.get("/")
def index():
  return ui.render(ui.pages.About, props=Stats(total_users=100))

```

### 4.3 Example page

On frontend side page will look like this:

```tsx

import {useProps} from "@schorle/shared";
import {Stats} from "@/lib/types"; // Stats type is autogenerated from pydantic models

export default function Index() {
  const stats = useProps<Stats>(); 

  // please note totalUsers and not total_users (!)
  // converted objects and types will have camelCase in JS
  return (<div> Total users: {stats.totalUsers} </div>)
}
```

## 5) Dev vs Prod Behavior

### Dev Mode

- **File watcher** monitors template and component changes
- **Automatic rebuilds** when files change
- **Fast rebuild** times due to Bun's performance
- **Source maps** enabled for debugging

### Prod Mode

- **Pre-built bundles** optimized and minified
- **Cached rendering** for frequently accessed pages
- **Static asset serving** for client bundle
- **Optimized slx-ipc** process pool for concurrent rendering

## 6) Cross-Platform Notes

- **Bun required** for build and rendering processes
- **slx-ipc CLI** works on Linux/macOS/Windows
- **No Unix sockets** needed - pure stdin/stdout communication
- **Fallback to Node.js** not supported - Bun is required
