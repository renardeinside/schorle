---
alwaysApply: true
---

# Schorle Framework Development Guide

## Tooling

- **ALWAYS** use `uv` for Python package management
- **ALWAYS** use `bun` for node package management
- **ALWAYS** to run `python` use `uv` in a form of `uv run python ...`

Project uses:

- FastAPI
- asyncio
- NextJS
- shadcn

## Overview

**Schorle** is a hybrid Python/TypeScript framework that bridges the gap between Python backend development and modern frontend user interfaces. It enables developers to build full-stack applications using Python for business logic while leveraging React/TypeScript for UI components, all within a unified development experience.

## Problem Statement & Solution

Modern Python development lacks the sophisticated frontend development experience available in JavaScript ecosystems. Developers typically face these suboptimal choices:

1. **Server-side rendering** with static HTML (FastAPI/Flask + Jinja2) - Limited interactivity and modern UI patterns
2. **WebSocket-based frameworks** (Streamlit/Dash/Reflex.dev) - Poor scaling due to per-page connections and limited UI flexibility
3. **Separate codebases** (FastAPI + React/Next.js) - Increased complexity, duplication, and coordination overhead
4. **Pure JavaScript solutions** (Next.js) - Loss of Python's ecosystem and development experience

**Schorle's approach:** Provides a unified development model where Python handles application logic and data while TypeScript/React manages UI rendering, connected through a sophisticated Inter-Process Communication (IPC) layer that maintains type safety and performance.

## Schorle – Cursor Instructions (Updated Proxy + UDS Architecture)

> **TL;DR**  
> Schorle now **proxies page/API requests to a running Next.js app** (dev & prod), so you can use **almost the full Next.js feature set** (App Router, layouts, routing, Middleware, API routes, HMR, etc.).  
> **Python remains the entrypoint** and orchestrator. For **Python⇄Next data exchange**, Schorle runs a **Unix Domain Socket (UDS) key-value server**. Python writes data by key; Next fetches it by key using a request header.

---

## 0) Ground Rules for Cursor

- **Assume Next.js is the renderer of pages.**
- **Always proxy** page/API routes from Python → Next.js, preserving headers & methods.
- **Never touch `/_next/*`** except to proxy it; this path is **Next’s internal** assets/HMR.  
  - Use `/_next/*` (one underscore) — **do not** invent `/__next/*`.
- **Data exchange** from Python to Next happens via **SocketStore** + the request header **`x-schorle-props-id`**.
- **Bun runtime is preferred** to run Next (supports `fetch({ unix })`); fall back to Node + TCP store when Bun/UDS is unavailable.
- fall back to **TCP** store (named pipes are not supported here).

## 1) Process Topology

- **Python (FastAPI)**: public HTTP server, owns lifecycle, proxies to Next, runs UDS/TCP **SocketStore**.
- **Next.js (App Router)**: runs under **Bun** in dev/prod; Python starts/supervises it.
- **SocketStore (UDS)**: tiny in-memory KV server listening on a **UNIX socket path** (Linux/macOS) or **TCP** fallback (Windows/Node).

```bash
Client ──HTTP──▶ Python (FastAPI)
│ │
│ (proxy pages)
│ ▼
│ Next.js (HMR, routing, API routes, middleware)
│
└──(implicit props)──▶ SocketStore (UDS/TCP) ⇦ Python writes by key, Next reads via fetch
```

## 2) Python Side – Proxy + Props Injection

### 2.1 Request Flow (what to generate)

- For **every route** that belongs to the Next app (pages, API routes, static assets), **proxy** to Next:
  - Preserve method, path, query, body, and relevant headers (`cookie`, `authorization`, etc.).
  - Add/forward `x-forwarded-*` headers.
- Before proxying a request that requires server-provided props:
  1. Serialize props (e.g., **MessagePack**).
  2. Store in **SocketStore** under a **random key**.
  3. Attach header `x-schorle-props-id: <key>` when proxying to Next

## Usage of Server-side props in NextJS

```jsx
// app/stats/page.tsx (Server Component)
import { getProps } from "@/lib/store";

export default async function StatsPage() {
  const { totalUsers } = await getProps<{ totalUsers: number }>();
  return <div>Users: {totalUsers}</div>;
}
```

## Dev vs Prod Behavior

### Dev

Python starts Bun + Next dev (HMR enabled).

Proxies:

```/_next/* and /_next/webpack-hmr → Next dev```

All pages are proxied into NextJS.

File watcher (watchfiles) triggers any registry or metadata refresh you maintain (do not SSR pages in Python).

### Prod

Adds `/_next` route to serve static contents.

The main process is the one which keeps nodeJS running - implemented in `IpcManager`.

## Cross-Platform Notes

- UDS: Linux/macOS only. Uses 2 sockets: `/tmp/slx` and `/tmp/slx-store`.
- Windows: compatability mode via TCP
