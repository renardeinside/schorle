---
title: Backend-UI Interactions
description: How the Python backend communicates with the React frontend
---

import { File, Folder, Files } from "fumadocs-ui/components/files";
import { Callout } from "fumadocs-ui/components/callout";

## Server-side Parameters for Pages

Pages can receive data from the Python backend through server-side parameter injection. A page can be defined as follows:

```jsx
import { useParams } from "schorle";

export default function Greeting() {
  const { name, greeting } = useParams();
  return (
    <div>
      <h1>
        {greeting}, {name}!
      </h1>
    </div>
  );
}
```

From the server side, the page can be accessed as follows:

```python
from charming_aurora.ui import Greeting

@app.get("/greeting")
def greeting():
    return Greeting(name="John", greeting="Hello")
```

## Client-side API Fetching

The client-side API is automatically generated from the server-side API. For example:

```python
from pydantic import BaseModel

class Profile(BaseModel):
    name: str
    age: int

api = FastAPI()

@api.get("/profile")
async def profile() -> Profile:
    return Profile(name="John", age=30)
```

The client-side API will be automatically generated and put into `@/lib/api.ts` file.

```tsx
import { useProfile } from "@/lib/api";

export default function ProfileComponent() {
  const { data } = useProfile();
  return <div>{data.name}</div>;
}
```

## Layouts

To add layouts to a page, use `__layout.tsx` file. For example:

<Files>
  <Folder name="src" defaultOpen>
    <Folder name="charming_aurora" defaultOpen>
      <Folder name="ui" defaultOpen>
        <Folder name="lib">
          <File name="api.ts" />
        </Folder>
        <Folder name="components">
          <File name="button.tsx" />
        </Folder>
        <Folder name="pages" defaultOpen>
          <File name="__layout.tsx" />
          <File name="Index.tsx" />
          <Folder name="dashboard" defaultOpen>
            <File name="__layout.tsx" />
            <File name="Admin.tsx" />
            <File name="User.tsx" />
          </Folder>
        </Folder>
      </Folder>
    </Folder>
  </Folder>
</Files>

Pages will be automatically wrapped in the layout.

<Callout>
    Layouts are nested, e.g. the `pages/__layout.tsx` is considered as "root" layout, while `pages/dashboard/__layout.tsx` is considered as "dashboard" layout:
    ```tsx
    // assuming we are in the /dashboard/user page.
    // it will be wrapped into <RootLayout> and <DashboardLayout>
    <RootLayout>
      <DashboardLayout>
        <User />
      </DashboardLayout>
    </RootLayout>
    ```
</Callout>

The `__layout.tsx` file can be defined as follows:

```tsx
import { Outlet } from "schorle";

export default function Layout() {
  return (
    <div>
      <Outlet />
    </div>
  );
}
```

## Advanced Server-side Parameters

Pages might require additional server-side information, such as:

- Response headers
- SEO metadata
- Cache directives

All of this can be added to the page as arguments:

```python
@app.get("/")
def read_root():
    return Index(
        title="My App",
        description="My App description",
        headers={
            "Cache-Control": "max-age=3600",
        },
        seo={
            "title": "My App",
            "description": "My App description",
        },
    )
```

## How the IPC Works

During development, schorle will automatically check the `[tool.schorle]` section in the `pyproject.toml` file:

```toml
[tool.schorle]
frontend_root_path = "src/charming_aurora/ui"
```

Schorle will automatically compile the frontend code and create an `__init__.py` file in the specified directory.

This file will contain automatically generated code:

```python
# this code is automatically generated by schorle, don't edit it manually
from schorle import Page, Assets

class Index(Page):
    source_file = "src/charming_aurora/ui/pages/Index.tsx"
    assets = Assets(
        css_file = "src/charming_aurora/ui/dist/index.css",
        js_file = "src/charming_aurora/ui/dist/index.js",
    )
```

If frontend code uses `useParams` hook, schorle will automatically add the corresponding parameters:

```python
class Greeting(Page):
    # snip...
    name: str
    greeting: str
```

### Runtime Architecture

During page serving, schorle uses a sophisticated Inter-Process Communication (IPC) system:

- **Runtime:** Embedded Bun JavaScript engine running in-process within Python
- **Communication:** Jupyter kernel protocol for bidirectional message passing
- **Serialization:** JSON with automatic TypeScript/Python type mapping
- **Process Model:** Single-process architecture (no separate servers or threading)

Any changes in the frontend code are automatically detected and the Python bindings are updated accordingly.

Bun is used in-process, without calling external servers or running in separate threads. To communicate with Bun, a Jupyter-based Python client is used, and Bun is automatically installed during the development run.
