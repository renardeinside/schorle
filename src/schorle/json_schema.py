import copy
import json
import inspect
import importlib
from pathlib import Path
import subprocess
from types import ModuleType
from typing import Any
from pydantic import BaseModel
from pydantic.json_schema import GenerateJsonSchema, JsonSchemaMode
from pydantic_core import CoreSchema


def find_models(module: ModuleType) -> list[type[BaseModel]]:
    if isinstance(module, str):
        module = importlib.import_module(module)

    models = []
    for _, obj in inspect.getmembers(module, inspect.isclass):
        if obj.__module__ != module.__name__:
            continue
        if not issubclass(obj, BaseModel):
            continue
        models.append(obj)
    return models


def _to_camel(s: str) -> str:
    parts = s.split("_")
    return parts[0] + "".join(p.capitalize() for p in parts[1:])


def _camelize_schema(schema: dict) -> dict:
    """
    Recursively convert JSON Schema property names (and `required` items)
    from snake_case to camelCase without altering the original schema.
    """

    def walk(node):
        if isinstance(node, dict):
            # Convert object properties
            if "properties" in node and isinstance(node["properties"], dict):
                node["properties"] = {
                    _to_camel(k): walk(v) for k, v in node["properties"].items()
                }
            # Keep required list in sync
            if "required" in node and isinstance(node["required"], list):
                node["required"] = [_to_camel(x) for x in node["required"]]

            # Recurse through common JSON Schema containers
            for key in (
                "items",
                "additionalProperties",
                "contains",
                "propertyNames",
                "if",
                "then",
                "else",
                "not",
            ):
                if key in node:
                    node[key] = walk(node[key])

            for key in ("allOf", "anyOf", "oneOf"):
                if key in node and isinstance(node[key], list):
                    node[key] = [walk(x) for x in node[key]]

            for key in ("$defs", "definitions"):
                if key in node and isinstance(node[key], dict):
                    node[key] = {k: walk(v) for k, v in node[key].items()}

            # Generic deep walk for any other nested dicts/lists
            for k, v in list(node.items()):
                if isinstance(v, dict):
                    node[k] = walk(v)
                elif isinstance(v, list):
                    node[k] = [walk(x) for x in v]
            return node

        if isinstance(node, list):
            return [walk(x) for x in node]
        return node

    return walk(copy.deepcopy(schema))


def generate_schemas(module: ModuleType) -> str:
    models: list[type[BaseModel]] = find_models(module)
    print(f"Found {len(models)} models in {module.__name__}")
    generator = GenerateJsonSchema()
    inputs: list[tuple[type[BaseModel], JsonSchemaMode, CoreSchema]] = [
        (m, "serialization", m.__pydantic_core_schema__) for m in models
    ]
    _, definitions = generator.generate_definitions(inputs)

    json_schema: dict[str, Any] = {}

    if definitions:
        json_schema["$defs"] = definitions

    json_schema["description"] = (
        f"JSON Schema for {module.__name__}, automatically generated by schorle"
    )
    json_schema["title"] = f"{module.__name__}"
    camelized_schema = _camelize_schema(json_schema)
    return json.dumps(camelized_schema, indent=2)


def schema_to_ts(json_schema_str: str, bun_executable: Path) -> str:
    # Ensure draft is explicit (helps some tools)
    try:
        obj = json.loads(json_schema_str)
    except json.JSONDecodeError:
        obj = None
    if isinstance(obj, dict) and "$schema" not in obj:
        obj["$schema"] = "https://json-schema.org/draft/2020-12/schema"
        json_schema_str = json.dumps(obj)

    cmd = [
        str(bun_executable),
        "x",
        "json-schema-to-typescript",
        "--unreachableDefinitions",  # emit all $defs even if not referenced
        "--format=false",  # (optional) skip prettier for speed
    ]
    proc = subprocess.run(
        cmd,
        input=json_schema_str,  # pass stdin directly
        text=True,  # let subprocess handle encoding/decoding
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        check=True,
    )
    return proc.stdout
