import shutil
import json
import subprocess
import typer
from pathlib import Path
import importlib.metadata
import importlib.resources
import os
from schorle.bun import check_and_prepare_bun
from schorle.json_schema import generate_schemas
from schorle.registry import registry
from schorle.utils import find_project_root, schema_to_ts

__version__ = importlib.metadata.version("schorle")
templates_path = importlib.resources.files("schorle").joinpath("templates")


app = typer.Typer(
    name="slx",
    help="Schorle is a framework for building powerful data-driven applications.",
)


@app.command(name="version", help="Show the version of the schorle CLI")
def version():
    typer.echo(f"Schorle version {__version__}")


@app.command(name="init", help="Initialize a new project")
def init(
    project_path: Path = typer.Argument(
        default_factory=lambda: Path.cwd(),
        help="The path to the project, usually ui or src/{python_project_name}/ui",
    ),
    project_name: str = typer.Argument("ui", help="The name of the project"),
    base_color: str = typer.Option(
        "neutral", help="The base color property for shadcn"
    ),
):
    typer.echo(f"Generating project {project_name} at {project_path}")

    if project_path.exists():
        typer.echo(f"Project path {project_path} already exists")
        raise typer.Exit(code=1)

    project_path.mkdir(parents=True, exist_ok=True)
    schorle_path = project_path / ".schorle"
    schorle_path.mkdir(parents=True, exist_ok=True)

    bun_executable = check_and_prepare_bun()

    # run bun init in project_path
    subprocess.run(
        [
            bun_executable,
            "create",
            "next-app",
            "schorle",
            "--use-bun",
            "--typescript",
            "--tailwind",
            "--yes",
        ],
        cwd=project_path,
    )

    os.rename(project_path / "schorle", schorle_path)

    # put project_name into .schorle/package.json
    package_json = schorle_path / "package.json"
    content = json.loads(package_json.read_text())
    content["name"] = project_name
    package_json.write_text(json.dumps(content, indent=2))

    # copy ../templates/.schorle/**/* to schorle_path
    shutil.copytree(
        str(templates_path / ".schorle"),
        schorle_path,
        dirs_exist_ok=True,
    )

    # remove .schorle/public folder
    shutil.rmtree(schorle_path / "public")

    # copy templates/app to project_path/app
    shutil.copytree(
        str(templates_path / "app"),
        project_path / "app",
        dirs_exist_ok=True,
    )

    first_letter = project_name[0].upper()
    logo_template = project_path / "app" / "public" / "logo.template.svg"
    logo_template.write_text(
        logo_template.read_text().replace("{{project_first_letter}}", first_letter)
    )
    shutil.copy(
        logo_template,
        project_path / "app" / "public" / "logo.svg",
    )

    logo_template.unlink()

    # remove default page.tsx
    (schorle_path / "app" / "page.tsx").unlink()

    # copy ../templates/tsconfig.json to project_path/tsconfig.json
    shutil.copy(
        str(templates_path / "tsconfig.json"),
        project_path / "tsconfig.json",
    )

    # add shadcn
    subprocess.run(
        [bun_executable, "x", "shadcn@latest", "init", "--yes", "-b", base_color],
        cwd=schorle_path,
    )
    # add next-themes
    subprocess.run(
        [bun_executable, "add", "next-themes", "@msgpack/msgpack"], cwd=schorle_path
    )

    # add button
    subprocess.run(
        [bun_executable, "x", "shadcn@latest", "add", "button"], cwd=schorle_path
    )

    # add
    # this -> @source "../../app/pages/";
    # after -> @import "tw-animate-css";
    # to file schorle_path/app/styles/globals.css
    styles_file = schorle_path / "app" / "globals.css"
    content = styles_file.read_text()
    content = content.replace(
        '@import "tw-animate-css";',
        "\n".join(
            [
                '@import "tw-animate-css";',
                '@source "../../app/";',
            ]
        ),
    )
    styles_file.write_text(content)

    # add symlink from schorle_path/node_modules to project_path/node_modules

    (project_path / "node_modules").symlink_to(
        Path(".schorle/node_modules"), target_is_directory=True
    )

    # gen pages
    registry(
        project_root=project_path,
        pages=Path("app/pages"),
        ts_out=Path(".schorle/app/registry.gen.tsx"),
        py_out=Path("registry.py"),
        import_prefix="@/pages",
    )

    # add __init__.py to project_path
    (project_path / "__init__.py").write_text(
        "\n".join(
            [
                "# This file is generated by schorle init",
                "from .registry import pages",
                "from schorle.app import Schorle",
                "from pathlib import Path",
                "ui = Schorle(Path(__file__).parent)",
                "__all__ = ['pages', 'ui']",
            ]
        )
    )


app.command(
    name="registry",
    help="Scan a /pages tree and emit a TypeScript lazy-import registry.",
)(registry)


@app.command("build", help="Generate the registry and build the UI")
def build():
    project_root = find_project_root()
    if project_root is None:
        typer.echo(f"Project root not found after searching in {Path.cwd()}")
        raise typer.Exit(code=1)

    print(f"Building project {project_root}")

    schorle_path = project_root / ".schorle"

    # generate registry
    registry(
        pages=project_root / "app" / "pages",
        ts_out=schorle_path / "app" / "registry.gen.tsx",
        py_out=project_root / "registry.py",
        import_prefix="@/pages",
    )

    # next JS build
    bun_executable = check_and_prepare_bun()
    subprocess.run([bun_executable, "run", "build"], cwd=schorle_path)


@app.command("codegen", help="Generate models from the project")
def generate_models(
    module_name: str = typer.Argument(
        help="The name of the module to generate models for",
    ),
):
    project_root = find_project_root()
    if project_root is None:
        typer.echo(f"Project root not found after searching in {Path.cwd()}")
        raise typer.Exit(code=1)

    # generate models
    bun_executable = check_and_prepare_bun()
    module = importlib.import_module(module_name)
    json_schema = generate_schemas(module)
    ts_schema = schema_to_ts(json_schema, bun_executable)
    types_dir = project_root / "app" / "lib" / "types"
    types_dir.mkdir(parents=True, exist_ok=True)
    output_path = types_dir / f"{module_name}.d.ts"
    typer.echo(f"Writing models to {output_path}")

    barrel_file = types_dir / "index.d.ts"
    # check if barrel_file exists
    if not barrel_file.exists():
        barrel_file.write_text(
            "\n".join(
                [
                    f"export * from './{module_name}.d.ts';",
                ]
            )
        )
    else:
        # check if export * from './{module_name}.d.ts'; exists, add it if not
        if f"export * from './{module_name}.d.ts';" not in barrel_file.read_text():
            current_content = barrel_file.read_text()
            barrel_file.write_text(
                current_content + f"\nexport * from './{module_name}.d.ts';"
            )
    current_ts_content = (
        output_path.read_text(encoding="utf-8") if output_path.exists() else ""
    )
    if ts_schema != current_ts_content:
        output_path.write_text(ts_schema, encoding="utf-8")


add_app = typer.Typer(
    name="add",
    help="Add components or dependencies to the project",
)
app.add_typer(add_app, name="add")


component_args = {
    "help": """Add a component to the project.

    This command will run `bun x shadcn@latest add component` with the remaining arguments.

    Example:

    > slx add component button
    """,
    "context_settings": {"allow_extra_args": True, "ignore_unknown_options": True},
}


@add_app.command("component", **component_args)  # type: ignore
@add_app.command("comp", **component_args)  # type: ignore
@add_app.command("c", **component_args)  # type: ignore
def add_component(
    ctx: typer.Context,
):
    bun_executable = check_and_prepare_bun()
    cwd = Path.cwd()
    schorle_path = cwd / ".schorle"
    # check if .schorle folder exists in cwd
    if not schorle_path.exists():
        typer.echo(f"Project path {cwd} does not have a .schorle folder")
        raise typer.Exit(code=1)

    # run bun x shadcn@latest add component with the remaining arguments
    subprocess.run(
        [bun_executable, "x", "shadcn@latest", "add", *ctx.args], cwd=schorle_path
    )


dependency_args = {
    "help": """Add a dependency to the project.

    This command will run `bun add` with the remaining arguments.
    """,
    "context_settings": {"allow_extra_args": True, "ignore_unknown_options": True},
}


@add_app.command("dependency", **dependency_args)  # type: ignore
@add_app.command("dep", **dependency_args)  # type: ignore
@add_app.command("d", **dependency_args)  # type: ignore
def add_dependency(
    ctx: typer.Context,
):
    bun_executable = check_and_prepare_bun()
    cwd = Path.cwd()
    schorle_path = cwd / ".schorle"
    # check if .schorle folder exists in cwd
    if not schorle_path.exists():
        typer.echo(f"Project path {cwd} does not have a .schorle folder")
        raise typer.Exit(code=1)

    # run bun add with the remaining arguments
    subprocess.run([bun_executable, "add", *ctx.args], cwd=schorle_path)
