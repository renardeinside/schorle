from __future__ import annotations

import time
from dataclasses import dataclass
from pathlib import Path

import typer
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text

app = typer.Typer(add_completion=False)
console = Console()


# ---------- Types ----------
@dataclass
class FoundPage:
    route_id: str  # posix path under pages (no ext)
    abs_file: Path  # absolute file path
    layout_imports: list[str]  # "@/pages/.../__layout"
    page_import: str  # "@/pages/.../File"


# ---------- Utils ----------
def to_posix(p: Path | str) -> str:
    return str(p).replace("\\", "/")


def is_tsx_page(file: Path) -> bool:
    return file.suffix == ".tsx" and file.name != "__layout.tsx"


def has_layout(dir_path: Path) -> bool:
    return (dir_path / "__layout.tsx").exists()


def ensure_dir_for_file(out_file: Path) -> None:
    out_file.parent.mkdir(parents=True, exist_ok=True)


# ---------- Core ----------
def collect_layouts_for(
    file_abs: Path, pages_dir_abs: Path, import_prefix: str
) -> list[str]:
    """
    Build ancestor chain from pages_dir_abs -> dir_of_file, and include any __layout.tsx found.
    """
    layouts: list[str] = []
    dir_abs = file_abs.parent

    # Build ancestor chain (including pages root)
    try:
        rel_dir = dir_abs.relative_to(pages_dir_abs)
        parts = rel_dir.parts
    except ValueError:
        # file not under pages_dir_abs
        parts = ()

    chain: list[Path] = [pages_dir_abs]
    for i in range(len(parts)):
        chain.append(pages_dir_abs.joinpath(*parts[: i + 1]))

    for d in chain:
        if has_layout(d):
            rel = ""
            try:
                rel = to_posix(d.relative_to(pages_dir_abs))
            except ValueError:
                rel = ""
            imp = (
                f"{import_prefix}/{rel}/__layout"
                if rel
                else f"{import_prefix}/__layout"
            )
            layouts.append(imp)

    return layouts


def walk_pages(
    dir_abs: Path,
    pages_dir_abs: Path,
    import_prefix: str,
    acc: list[FoundPage] | None = None,
) -> list[FoundPage]:
    if acc is None:
        acc = []

    # Sort directories and files by name for stable output
    entries = sorted(dir_abs.iterdir(), key=lambda p: (p.is_file(), p.name))

    for e in entries:
        if e.is_dir():
            walk_pages(e, pages_dir_abs, import_prefix, acc)
        elif e.is_file() and is_tsx_page(e):
            rel_no_ext = to_posix(e.relative_to(pages_dir_abs).with_suffix(""))
            layout_imports = collect_layouts_for(e, pages_dir_abs, import_prefix)
            page_import = f"{import_prefix}/{rel_no_ext}"
            acc.append(
                FoundPage(
                    route_id=rel_no_ext,
                    abs_file=e.resolve(),
                    layout_imports=layout_imports,
                    page_import=page_import,
                )
            )
    return acc


def generate_ts_registry(pages: list[FoundPage]) -> str:
    header = """/* AUTO-GENERATED by build_page_registry.py — do not edit by hand */
/// <reference types="react" />

import type { ReactNode } from "react";
import type { JSX } from "react";

export type LayoutFC = (props: { children: ReactNode }) => JSX.Element;

export type PageRegistryEntry = {
  layouts: LayoutFC[];
  Page: React.ComponentType<any>;
};

export type PageRegistry = Record<string, PageRegistryEntry>;

export function wrapLayouts(
  Page: React.ComponentType,
  layouts: LayoutFC[]
): React.ReactElement {
  const tree = layouts.reduceRight<React.ReactNode>(
    (child, Layout) => <Layout>{child}</Layout>,
    <Page />
  );
  return <>{tree}</>;
}

"""
    entries_parts: list[str] = []
    for p in pages:
        if len(p.layout_imports) == 0:
            layouts_array = "[]"
        else:
            awaited = ",\n".join(
                f'    (await import("{imp}")).default' for imp in p.layout_imports
            )
            layouts_array = f"[\n{awaited}\n  ]"

        entries_parts.append(
            f"  {repr(p.route_id)}: {{\n"
            f"    layouts: {layouts_array},\n"
            f'    Page: (await import("{p.page_import}")).default,\n'
            f"  }}"
        )

    body = (
        "export const pageRegistry: PageRegistry = {\n"
        + ",\n".join(entries_parts)
        + "\n};\n\nexport default pageRegistry;\n"
    )
    return header + body


def warn_missing_layouts(pages_dir: Path, pages: list[FoundPage]) -> None:
    # Any directory that directly contains a page but has no __layout.tsx
    dirs_with_pages = {p.abs_file.parent for p in pages}
    for d in sorted(
        dirs_with_pages,
        key=lambda p: to_posix(p.relative_to(pages_dir))
        if p.is_relative_to(pages_dir)
        else to_posix(p),
    ):
        if not has_layout(d):
            rel = "."
            try:
                rel = to_posix(d.relative_to(pages_dir))
                if rel == "":
                    rel = "."
            except ValueError:
                rel = to_posix(d)
            console.print(
                f":warning: [yellow]Missing[/yellow] [bold]__layout.tsx[/bold] in [white]{rel}[/white]"
            )


# ---------- CLI ----------
def registry(
    pages: Path = typer.Argument(..., help="Path to pages root (e.g. ./pages)"),
    out: Path = typer.Argument(..., help="Output file (e.g. ./app/gen.registry.ts)"),
    import_prefix: str = typer.Argument(
        "@/pages",
        help='Module spec prefix for imports, e.g. "@/pages"',
    ),
):
    t0 = time.perf_counter()

    info = Table.grid(padding=(0, 10))
    info.add_row(
        ":open_file_folder:  [bold]pages[/bold]", f"[dim]{pages.resolve()}[/dim]"
    )
    info.add_row(":outbox_tray:  [bold]out[/bold]  ", f"[dim]{out.resolve()}[/dim]")
    info.add_row(":label:   [bold]prefix[/bold]", f"[dim] {str(import_prefix)}[/dim]")
    console.print(info)

    if not pages.exists() or not pages.is_dir():
        console.print(f":x: [red]Pages directory not found:[/red] {pages.resolve()}")
        raise typer.Exit(code=1)

    try:
        pages_list = walk_pages(pages.resolve(), pages.resolve(), import_prefix, acc=[])
    except Exception as e:
        console.print(f":x: [red]Error while scanning pages:[/red] {e}")
        raise typer.Exit(code=1)

    page_count = len(pages_list)
    if page_count == 0:
        console.print(
            ":warning: [yellow]No pages found[/yellow] under "
            f"[white]{to_posix(pages.resolve())}[/white]"
        )

    warn_missing_layouts(pages.resolve(), pages_list)

    try:
        content = generate_ts_registry(pages_list)
        ensure_dir_for_file(out.resolve())
        out.write_text(content, encoding="utf-8")
    except Exception as e:
        console.print(f":x: [red]Failed to write registry file:[/red] {e}")
        raise typer.Exit(code=1)

    dt_ms = (time.perf_counter() - t0) * 1000
    console.print(
        f":white_check_mark: [green]Wrote registry[/green] "
        f"[bold]{page_count}[/bold] page(s) → [cyan]{to_posix(out.resolve())}[/cyan] "
        f"[dim]({dt_ms:.1f}ms)[/dim]"
    )
