from __future__ import annotations

import time
from dataclasses import dataclass
from pathlib import Path

import typer
from rich.console import Console
from rich.table import Table

app = typer.Typer(add_completion=False)
console = Console()


# ---------- Types ----------
@dataclass
class FoundPage:
    route_id: str  # posix path under pages (no ext)
    abs_file: Path  # absolute file path
    layout_imports: list[str]  # "@/pages/.../__layout"
    page_import: str  # "@/pages/.../File"


# ---------- Utils ----------
def to_posix(p: Path | str) -> str:
    return str(p).replace("\\", "/")


def is_tsx_page(file: Path) -> bool:
    return file.suffix == ".tsx" and file.name != "__layout.tsx"


def has_layout(dir_path: Path) -> bool:
    return (dir_path / "__layout.tsx").exists()


def ensure_dir_for_file(out_file: Path) -> None:
    out_file.parent.mkdir(parents=True, exist_ok=True)


# ---------- Core ----------
def collect_layouts_for(
    file_abs: Path, pages_dir_abs: Path, import_prefix: str
) -> list[str]:
    """
    Build ancestor chain from pages_dir_abs -> dir_of_file, and include any __layout.tsx found.
    """
    layouts: list[str] = []
    dir_abs = file_abs.parent

    # Build ancestor chain (including pages root)
    try:
        rel_dir = dir_abs.relative_to(pages_dir_abs)
        parts = rel_dir.parts
    except ValueError:
        # file not under pages_dir_abs
        parts = ()

    chain: list[Path] = [pages_dir_abs]
    for i in range(len(parts)):
        chain.append(pages_dir_abs.joinpath(*parts[: i + 1]))

    for d in chain:
        if has_layout(d):
            rel = ""
            try:
                rel = to_posix(d.relative_to(pages_dir_abs))
            except ValueError:
                rel = ""
            imp = (
                f"{import_prefix}/{rel}/__layout"
                if rel
                else f"{import_prefix}/__layout"
            )
            layouts.append(imp)

    return layouts


def walk_pages(
    dir_abs: Path,
    pages_dir_abs: Path,
    import_prefix: str,
    acc: list[FoundPage] | None = None,
) -> list[FoundPage]:
    if acc is None:
        acc = []

    # Sort directories and files by name for stable output
    entries = sorted(dir_abs.iterdir(), key=lambda p: (p.is_file(), p.name))

    for e in entries:
        if e.is_dir():
            walk_pages(e, pages_dir_abs, import_prefix, acc)
        elif e.is_file() and is_tsx_page(e):
            rel_no_ext = to_posix(e.relative_to(pages_dir_abs).with_suffix(""))
            layout_imports = collect_layouts_for(e, pages_dir_abs, import_prefix)
            page_import = f"{import_prefix}/{rel_no_ext}"
            acc.append(
                FoundPage(
                    route_id=rel_no_ext,
                    abs_file=e.resolve(),
                    layout_imports=layout_imports,
                    page_import=page_import,
                )
            )
    return acc


def generate_ts_registry(pages: list[FoundPage]) -> str:
    header = """/* AUTO-GENERATED by build_page_registry.py â€” do not edit by hand */
/// <reference types="react" />

import type { ReactNode } from "react";
import type { JSX } from "react";

export type LayoutFC = (props: { children: ReactNode }) => JSX.Element;

export type PageRegistryEntry = {
  layouts: LayoutFC[];
  Page: React.ComponentType<any>;
};

export type PageRegistry = Record<string, PageRegistryEntry>;

export function wrapLayouts(
  Page: React.ComponentType,
  layouts: LayoutFC[]
): React.ReactElement {
  const tree = layouts.reduceRight<React.ReactNode>(
    (child, Layout) => <Layout>{child}</Layout>,
    <Page />
  );
  return <>{tree}</>;
}

"""
    entries_parts: list[str] = []
    for p in pages:
        if len(p.layout_imports) == 0:
            layouts_array = "[]"
        else:
            awaited = ",\n".join(
                f'    (await import("{imp}")).default' for imp in p.layout_imports
            )
            layouts_array = f"[\n{awaited}\n  ]"

        entries_parts.append(
            f"  {repr(p.route_id)}: {{\n"
            f"    layouts: {layouts_array},\n"
            f'    Page: (await import("{p.page_import}")).default,\n'
            f"  }}"
        )

    body = (
        "export const pageRegistry: PageRegistry = {\n"
        + ",\n".join(entries_parts)
        + "\n};\n\nexport default pageRegistry;\n"
    )
    return header + body


def warn_missing_layouts(pages_dir: Path, pages: list[FoundPage]) -> None:
    # Any directory that directly contains a page but has no __layout.tsx
    dirs_with_pages = {p.abs_file.parent for p in pages}
    for d in sorted(
        dirs_with_pages,
        key=lambda p: to_posix(p.relative_to(pages_dir))
        if p.is_relative_to(pages_dir)
        else to_posix(p),
    ):
        if not has_layout(d):
            rel = "."
            try:
                rel = to_posix(d.relative_to(pages_dir))
                if rel == "":
                    rel = "."
            except ValueError:
                rel = to_posix(d)
            console.print(
                f":warning: [yellow]Missing[/yellow] [bold]__layout.tsx[/bold] in [white]{rel}[/white]"
            )


def generate_py_registry(pages: list[FoundPage]) -> str:
    """
    Produce a Python module with:
      - One top-level class per top-level directory under /pages
      - A root `pages` class listing top-level pages and re-exporting folder classes

    Example (for pages like "Index", "User", "Product", "dashboard/User", "dashboard/Product"):

        # AUTO-GENERATED by schorle registry command, do not edit by hand

        class dashboard:
            User = "/User"  # /dashboard/user
            Product = "/Product"  # /dashboard/product

        class pages:
            Index = "/Index"  # /index
            User = "/User"  # /user
            Product = "/Product"  # /product
            dashboard = dashboard
    """

    # --- helpers ---
    def split_route(route_id: str) -> list[str]:
        return route_id.split("/") if route_id else []

    def comment_path(segments: list[str]) -> str:
        # lower-cased URL-style comment like "/dashboard/user"
        return "/" + "/".join(s.lower() for s in segments)

    # Collect top-level pages and top-level folder -> immediate pages
    top_level_pages: set[str] = set()
    folder_pages: dict[str, set[str]] = {}

    for p in pages:
        segs = split_route(p.route_id)
        if not segs:
            continue
        if len(segs) == 1:
            # Top-level page
            top_level_pages.add(segs[0])
        else:
            # Page under a top-level folder; we only expose the immediate folder class
            folder = segs[0]
            leaf = segs[-1]
            folder_pages.setdefault(folder, set()).add(leaf)

    # Start building output
    lines: list[str] = []
    lines.append("# AUTO-GENERATED by schorle registry command, do not edit by hand")
    lines.append("")

    # Emit one class per top-level folder
    for folder in sorted(folder_pages.keys()):
        lines.append(f"class {folder}:")
        pages_in_folder = sorted(folder_pages[folder])
        if not pages_in_folder:
            lines.append("    pass")
        else:
            for name in pages_in_folder:
                # Value is the leaf (e.g., "/User"); comment shows full lowercased path
                lines.append(
                    f'    {name} = "/{name}"  # {comment_path([folder, name])}'
                )
        lines.append("")

    # Emit root `pages` class
    lines.append("class pages:")
    emitted_any = False

    for name in sorted(top_level_pages):
        lines.append(f'    {name} = "/{name}"  # {comment_path([name])}')
        emitted_any = True

    for folder in sorted(folder_pages.keys()):
        lines.append(f"    {folder} = {folder}")
        emitted_any = True

    if not emitted_any:
        lines.append("    pass")

    lines.append("")

    return "\n".join(lines)


# ---------- CLI ----------
def registry(
    pages: Path = typer.Argument(
        Path("app/pages"), help="Path to pages root (e.g. ./pages)"
    ),
    ts_out: Path = typer.Argument(
        Path("app/gen.registry.ts"), help="Output file (e.g. ./app/gen.registry.ts)"
    ),
    py_out: Path = typer.Argument(
        Path("registry.py"), help="Output file for python module"
    ),
    import_prefix: str = typer.Argument(
        "@/pages",
        help='Module spec prefix for imports, e.g. "@/pages"',
    ),
):
    t0 = time.perf_counter()

    info = Table.grid(padding=(0, 10))
    info.add_row(
        ":open_file_folder:  [bold]pages[/bold]", f"[dim]{pages.resolve()}[/dim]"
    )
    info.add_row(":outbox_tray:  [bold]out[/bold]  ", f"[dim]{ts_out.resolve()}[/dim]")
    info.add_row(":label:   [bold]prefix[/bold]", f"[dim] {str(import_prefix)}[/dim]")
    console.print(info)

    if not pages.exists() or not pages.is_dir():
        console.print(f":x: [red]Pages directory not found:[/red] {pages.resolve()}")
        raise typer.Exit(code=1)

    try:
        pages_list = walk_pages(pages.resolve(), pages.resolve(), import_prefix, acc=[])
    except Exception as e:
        console.print(f":x: [red]Error while scanning pages:[/red] {e}")
        raise typer.Exit(code=1)

    page_count = len(pages_list)
    if page_count == 0:
        console.print(
            ":warning: [yellow]No pages found[/yellow] under "
            f"[white]{to_posix(pages.resolve())}[/white]"
        )

    warn_missing_layouts(pages.resolve(), pages_list)

    try:
        ts_content = generate_ts_registry(pages_list)
        py_content = generate_py_registry(pages_list)
        ensure_dir_for_file(ts_out.resolve())
        ts_out.write_text(ts_content, encoding="utf-8")

        ensure_dir_for_file(py_out.resolve())
        py_out.write_text(py_content, encoding="utf-8")
    except Exception as e:
        console.print(f":x: [red]Failed to write registry file:[/red] {e}")
        raise typer.Exit(code=1)

    dt_ms = (time.perf_counter() - t0) * 1000
    console.print(
        f":white_check_mark: [green]Wrote registry[/green] "
        f"[bold]{page_count}[/bold] page(s) â†’ [cyan]{to_posix(ts_out.resolve())}[/cyan] "
        f"[cyan]{to_posix(py_out.resolve())}[/cyan] "
        f"[dim]({dt_ms:.1f}ms)[/dim]"
    )
